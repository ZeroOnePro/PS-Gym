# 0x10 다이나믹 프로그래밍

<!--ts-->

- [0x10 다이나믹 프로그래밍](#0x10-다이나믹-프로그래밍)
  - [0x00 알고리즘 설명](#0x00-알고리즘-설명)
  - [0x01 연습 문제](#0x01-연습-문제)
  - [0x02 경로 추적](#0x02-경로-추적)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 6월 30일 목요일 13시 29분 31초 KST -->

<!--te-->

다이나믹 프로그래밍은 다양한 문제를 풀면서 익히는 유형이다
많은 문제를 풀어보며 별의별 테이블과 점화식을 만나면서 기계가 될 때까지 숙달하자

## 0x00 알고리즘 설명

- 여러 개의 하위 문제를 먼저 푼 후 그 결과를 쌓아올려 주어진 문제를 해결하는 알고리즘
- 문제를 해결하기 위한 점화식을 찾아낸 후 점화식의 항을 밑에서부터 차례로 구해나가서 답을 알아내는 형태의 알고리즘
- 중간 결과를 저장해서 이용하는지 그렇지 않은지에 따라 시간복잡도에서 드라마틱한 차이가 난다
  - 예시로 피보나치 수열을 재귀로 구현한 것과 DP로 구현한 것은 O($1.618^N$) vs O(N)
- DP를 푸는 과정
  1. 테이블 정의하기
     1. 공식이나 방법론이 있는게 아니라 경험적으로 익혀야 함
  2. 점화식 찾기
  3. 초기값 정하기

## 0x01 연습 문제

- 1463 - 1로 만들기
  - BFS로 해결 가능하다, 1을 초기값으로 한 뒤, +1, *2,*3 방향으로 각각 뻗어나가면 된다
  - 숨바꼭질 문제하고 비스무리하게 풀 수 있다 이말이여
  - But, DP를 이용하면 더 짧게 구현 가능하다
  - 테이블 정의하기
    - dp[i] = i를 1로 만들기 위해 필요한 연산 사용 횟수의 최솟값
  - 점화식 찾기
    - dp[12] = ?
    - dp[1] 부터 dp[11] 까지 값을 다 알고 있다고 가정할 때
    - 3으로 나누거나 (dp[12] = dp[4] + 1)
    - 2로 나누거나 (dp[12] = dp[4] + 1)
    - 1을 빼거나 (dp[12] = dp[11] + 1)
    - 최종적으로 dp[12]를 구하는 상황에서 점화식은 dp[12] = min(dp[4] + 1, dp[6] + 1, dp[11] + 1)이 된다
    - 이처럼 점화식이 바로 떠오르지 않을 때는 전개 시켜본다
    - 정리 dp[k] = min(dp[k/3]+1, dp[k/2]+1, dp[k-1]+1)
  - 초기값 정하기
    - 점화식은 초기값을 정의해줘야 전개할 수 있다
    - 배전 점화식이 전개될 수 있게 초기값이 어디까지 인지를 정의해줄 필요가 있다
    - 이 문제에서는 dp[1] = 0, 1은 연산 없이 1이 된다.
- 9095 - 1, 2, 3 더하기
  - 테이블 정의하기
    - dp[i] = i를 1, 2, 3의 합으로 나타내는 방법의 수
  - 점화식 찾기
    - dp[4] = ?
    - `강조`된 것이 고정되면 아래와 같이 됨
    - 1+1+1+`1` , 3+`1`, 2+1+`1`, 1+2+`1` ⇒ 3을 1, 2, 3으로 만드는 방법 + `1`, dp[3]
    - 1+1+`2`, 2+`2` ⇒ 2를 1, 2, 3으로 만드는 방법 + `2`, dp[2]
    - 1+`3` ⇒ 1을 1, 2, 3으로 만드는 방법 + `3`, dp[1]
    - 정리 dp[i] = dp[i-3] + dp[i-2] + dp[i-1]
  - 초기값 정하기
    - dp[1] = 1, dp[2] =2, dp[3] = 4로 정해줘야 점화식을 전개할 수 있다
- 2579 - 계단 오르기
  - 테이블 정의하기
    - dp[i] = i번째 계단까지 올라섰을 때 점수 합의 최댓값
    - 하지만 위의 점화식은 세 계단을 연속해서 밟으면 안된다는 제약조건을 점화식에 넣을 방법이 없다 따라서 다른 점화식을 찾아야함 → 점화식이 제약조건을 반영하지 못한다면 변수를 하나 더 늘려본다
    - dp[i][j] = 현재까지 j개의 계단을 연속해서 밟고(제약조건을 변수로) i번째 계단까지 올라섰을 때 점수 합의 최댓값, 단 i번째 계단은 반드시 밟아야함
  - 점화식 찾기
    - dp[k][1] = 현재까지 1개의 계단을 연속해서 올라섰을 때 k번째 계단에서 점수 합의 최댓값, 다시 말해 k-1번째 계단을 밟지 않았다는 의미이다, j=1은 이전 칸을 건너뛰었다는 의미, j=2는 이전 칸을 밟고 현재 칸에 도달했다는 의미 → max(dp[k-2][1], dp[k-2][2]) + stair[k]
    - dp[k][2] = 이전 칸을 밟았다는 소리이므로 k-1번째 계단에서의 경우의 수 dp[k-1][1], dp[k-1][2]이 있는데 dp[k-1][2]는 k-2를 밟았다는 소리이므로 k번째 계단을 밟게되면 연속해서 세 계단을 밟으면 안된다는 제약조건에 위배된다 → dp[k][2] = dp[k-1][1] + stair[i]
    - n번째 계단의 최대합은 max(dp[n][1], dp[n][2])
  - 초기값 정하기
    - dp[1][1] = stair[1], dp[1][2] = 0
    - dp[2][1] = stair[2], dp[2][2] = stair[1] + stair[2]
  - 관점을 바꿔보기
    - 여기서는 i번째 계단까지 올랐을 때 밟지 않은 계단들의 최소합을 구하는 것으로 해본다
    - 테이블 정의하기
      - dp[i] = i번째 계단까지 올랐을 때 밟지 않은 계단들의 최소합(대우 조건), 단 i번째 계단은 반드시 밟지 않을 계단으로 선택해야함(왜냐면 마지막 계단은 반드시 밟아야 한다는 제약조건 있었음)
    - 점화식 찾기
      - 직관적으로 안 떠오르면 테이블을 채워나가보는 것도 방법이다
      - i-1번째 계단은 반드시 밟아야함
      - i-2번째 또는 i-3번째 계단은 반드시 밟아야함
      - i를 건너뛴다 그랬고, dp[i]는 밟지 않은 계단들의 최소합이므로 i-2가 밟히지 않은 경우는 i-3과 i-1이 밟힌 경우이므로 dp[i-2] + stair[i]가 i번째 계단을 밟지 않았을 때의 합이고, i-3이 밟히지 않은 경우는 i-2와 i-1이 밟힌 경우이므로 dp[i-3] + stair[i]가 된다. → min(dp[i-3], dp[i-2]) + stair[i]
      - n번째 계단은 반드시 밟혀야 하므로 n-1번째나 n-2번째가 안 밟힌 경우를 보면 된다 계단 점수의 총합에서 안 밟힌 계단들의 누적합을 빼면 그 계단들은 안 밟힌게 되므로 총합 - min(dp[n-2], dp[n-1])이 된다.
    - 초기값 정하기
      - dp[1] = stair[1], dp[2] = stair[2], dp[3] = stair[3]
- 1149 - RGB거리
  - 테이블 정의하기
    - dp[i] = i번째 집을 칠할 때 최소 비용
    - 위 식으로만 감당이 안된다는 거는 알겠지? 왜냐면 인접한 집끼리 색이 달라야 한다는 제약조건이 있어서 그럼
    - dp[i][j] = i번째 집을 j색깔로 칠하는 경우 드는 최소 비용(j= 0, 1, 2로 각각 RGB를 나타냄)
  - 점화식 세우기
    - dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + color[i][0];
    - dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + color[i][1];
    - dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + color[i][2];
  - 초기값 정하기
    - dp[1][0] = color[1][0];
    - dp[1][1] = color[1][1];
    - dp[1][2] = color[1][2];
- 11726 - 2 x n 타일링

  - 테이블 정의하기
    - dp[i] = 2 X i 크기의 직사각형을 채우는 방법의 수
  - 점화식 세우기

    - 길이 N인 직사각형에서 가장 위쪽 칸을 생각해본다
    - 가장 위의 칸은 1 X 2 타일로 덮히거나 2 X 1 타일로 덮여야한다

      - 2 X 1 타일로 덮은 경우 남은 건 2 X N-1 칸이다
      - 가장 왼쪽 위의 칸을 2 X 1 타일로 덮는 경우의 수는 dp[n-1]이다

        ![1](https://user-images.githubusercontent.com/48282185/176592926-65ae1c01-bc46-4577-affc-9f44a5ff9125.png)

      - 1 X 2 타일로 덮은 경우 남은 건 2 X N-2 칸이다
      - 1 X 2 타일로 1행을 차지했으니 2행을 채울 수 있는 경우의 수는 1 X 2 타일로 정해진다

        ![2](https://user-images.githubusercontent.com/48282185/176592924-fc7c9f17-9f87-476e-8982-6ea93a34048c.png)

    - 정리
      - 2 X N 칸을 채울 때 왼쪽 위 칸을 2 X 1 타일로 덮으면 dp[n-1]
      - 2 X N 칸을 채울 때 왼쪽 위 칸을 1 X 2 타일로 덮으면 dp[n-2]
      - dp[n] = dp[n-1] + dp[n-2]

  - 초기값 정하기
    - dp[1] = 1
    - dp[2] = 2

- 11659 - 구간 합 구하기 4
  - 테이블 정의하기
    - dp[i] = a[1] + a[2] + … + a[i]
    - dp[i] = dp[i-1] + a[i]
    - i번째 원소까지의 누적합이라고 생각하고 테이블을 채워보자
  - 점화식 세우기
    - 어떻게 위와 같은 테이블을 유도하였을까?
    - a[i] + a[i+] + … + a[j]
      = (a[1] + .. + a[j]) - (a[1] + … + a[i-1])
      = dp[j] - dp[i-1]
    - 각 요청을 O(1)에 처리할 수 있다
    - 이 처럼 미리 누적합을 구해두고 특정 구간 내의 합을 구하는 기법을 prefix sum이라고 하고, 종종 시간복잡도를 줄이는 기법 중 하나로 쓰인다
  - 초기값 정하기
    - dp[0] = 0

## 0x02 경로 추적

- 12852 - 1로 만들기 2

  - 단순히 값 출력이 아닌 거쳐온 과정을 출력하라고 돼있다
  - 이런 문제를 해결하려면 테이블을 채울 때 추가적인 정보를 어딘가에 기입해야한다 → 경로 복원용 테이블
  - 7을 만드는 경우를 보자

    ![3](https://user-images.githubusercontent.com/48282185/176592912-32de1862-616d-4ff4-9ec5-d12660fa00c1.png)

    - pre[7] = 6, 7을 1로 만들기 위한 최적의 해에 6이 포함되어있다
    - pre[6] = 3, 6을 1로 만들기 위한 최적의 해에 3이 포함되어있다
    - pre[3] = 1, 3을 1로 만들려면 /3을 하면 되니 끝
    - 즉 7을 1로 만들기 위한 최적의 해는 7 6 3 1이다

  - 같은 원리로 BFS에서도 경로 복원이 가능하다

> 바킹독님 유튜브 강의를 참고하여 제작하였습니다.
