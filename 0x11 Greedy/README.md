# 0x11 그리디

<!--ts-->

- [0x11 그리디](#0x11-그리디)
  - [0x00 알고리즘 설명](#0x00-알고리즘-설명)
  - [0x01 연습 문제 1 - 동전 0](#0x01-연습-문제-1---동전-0)
  - [0x02 연습 문제 2 - 회의실 배정](#0x02-연습-문제-2---회의실-배정)
  - [0x03 연습 문제 3- 로프](#0x03-연습-문제-3--로프)
  - [0x04 연습 문제 4 - 보물](#0x04-연습-문제-4---보물)
  - [0x05 잘못된 그리디](#0x05-잘못된-그리디)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: sungminyou, at: 2022년 7월  1일 금요일 16시 41분 25초 KST -->

<!--te-->

이 유형은 보통 문제의 풀이가 그리디란 걸 캐치하기 어렵기 때문에 이것저것 다 시도해보다가 도저히 안되면 ‘혹시 그리디인가?’ 라는 생각에 풀이를 떠올리는 경우가 많다

그래서 유형을 모른채로 풀다가 ‘그리디한 접근법이 안될까?’ 머리를 굴려보면 도움이 될 것이다. 그리고 그리디 풀이의 정당성과 반례에 대해 고민을 계속 해보는 습관을 들여야한다

## 0x00 알고리즘 설명

- 매번 선택에서 지금 순간에 가장 최적인 답을 선택하는 근시안적 알고리즘
- 관찰을 통해 탐색 범위를 줄이는 알고리즘
- 예시로 길이가 각각 N, M인 두 리스트를 정렬하는 방법을 merge sort할 때 봤었는데 이것도 각 리스트의 제일 앞 원소끼리 비교해가면서 작은 원소를 선택한다는 점에서 O($(N + M)^2$)에서 O(N + M)으로 관찰을 통해 탐색 범위를 줄였었다
- 이상적인 풀이 흐름
  - 관찰을 통해 탐색 범위를 줄이는 방법을 고안한다
  - 탐색 범위를 줄여도 올바른 결과를 낸다는 사실을 수학적으로 증명한다
  - 구현해서 문제를 통과한다
- 코딩테스트에서의 추천 전략
  - 거의 똑같은 문제를 풀어봤었거나 간단한 문제여서 나의 그리디 풀이를 증명없이 100% 확신한다
    - 짜서 제출해보고 틀리면 빠르게 손절
  - 100% 확신은 없지만 맞는 것 같은 그리디 풀이를 찾았다
    - 일단은 넘어가고 다른 문제를 풀게 없거나 종료가 20-40분 남은 시점에 코딩 시작

## 0x01 연습 문제 1 - 동전 0

- dp로도 해결 가능하다 but, 시간 초과
  - dp[i] = 가치의 합을 i로 만들 때 필요한 동전 개수의 최솟값
  - dp[i] = min(dp[i- coin[1]], dp[i - coin[2]], …, dp[i - coin[n]]) + 1
- 그리디 풀이를 떠올려보자
  - 입력 받은 동전들 중 가장 큰 것부터 먼저 최대한으로 소모하는 것이 좋다
  - 예시로 입력 받은 동전의 종류들 중 500원이 제일 크다고 하자
  - 증명할 명제는 동전 개수를 최소화 하려면 500원 동전을 최대한 많이 써야 한다
  - 보조정리 1
    - 동전을 최소로 소모하면서 물건값을 지불하려면 10/100원 동전은 4개 이하, 50원 동전은 1개 이하로 사용해야 한다
  - 귀류법으로 증명 가능, 귀류법이란 명제가 거짓이라고 가정할 때 모순이 발생함을 보이는 증명법
  - 증명을 해보자
    - 10 / 100원 동전을 5개 이상 사용 → 50 / 500원 동전으로 대체
    - 50원 동전을 2개 이상 사용 → 100원 동전으로 대체
    - 보조정리 1이 거짓이라고 가정했을 때, 10 / 100원 동전을 5개 이상, 50원 동전을 2개 이상 사용해서 동전의 개수를 최소화 할 수 있다는 건데, 위처럼 대체되면서 소모한 동전의 수를 더 줄일 수 있다. 따라서 보조정리 1은 참이다
    - 10, 50, 100원 동전으로는 물건값을 최대 10 \* 4 + 50 \* 1 + 100 \* 4 = 490원만 감당 가능(보조 정리 1에 따라 사용할 수 있는 최대 개수로 만들어낸 최대합)하고, 500원을 다 사용하지 않을 경우 10, 50, 100원 동전으로 500원 이상 감당해야함
  - 동전들 간의 관계가 약수-배수가 아니라면 그리디 알고리즘으로 항상 올바른 답을 낼 수 없다. 반례로는 1, 9, 10원으로 18원 만들기

## 0x02 연습 문제 2 - 회의실 배정

- task scheduling problem이라는 그리디 대표 문제
- 일단 이 문제가 그리디 알고리즘으로 해결될 수 있다고 생각하지 않을 때 떠올릴 수 있는 문제 풀이 방안
  - 모든 가능한 배정 방법을 확인 → O($2^N$)
    - N개의 회의가 회의를 할 것이냐 말 것이냐
  - 동적계획법을 이용한 풀이 → O($N^2$)
    - 회의가 끝나는 시간이 빠른 순으로, 끝나는 시간이 같다면 시작 시간이 빠른 순으로 정렬
    - dp[i] = i번째 회의가 진행될 때까지 이전에 진행된 회의 수의 최대값
    - dp[i] = max(dp[j]) + 1(j번째 회의의 끝나는 시간이 i번째 회의의 시작 시간 이하인 모든 j)
  - 위의 두 가지 방법으로는 시간초과가 난다
  - 때문에 모든 회의를 보는 대신 더 줄일 수는 없을까? 라는 생각에 착안해야한다
- 그리디 풀이를 시작해보자

  ![1](https://user-images.githubusercontent.com/48282185/176848566-5c394b29-0f11-4d5b-ab65-80bc2600d789.png)

  - 가능한 회의 중에서 가장 먼저 끝나는 회의를 택하기
  - 왜냐하면 끝나는 시각이 작다는 것은 그만큼 회의가 일찍끝났다는 얘기고, 다음에 진행할 수 있는 회의를 더 많이 넣을 수 있다
  - 이 풀이가 맞는가?

    - 현재 시간이 t라고 할 때 시작 시간이 t 이상인 모든 회의 중에서 가장 먼저 끝나는 회의를 택하는 것이 최적해이다
    - 이 것의 증명 역시 귀류법으로 증명 가능하다

      ![2](https://user-images.githubusercontent.com/48282185/176848561-5c903b1e-8b9d-4d4f-be3d-97bff0ce67ad.png)

    - 회의 A대신 회의 B를 선택했을 때 더 많은 회의를 배정할 수 있다고 가정
    - 회의 B를 회의 A로 변경했을 때 문제가 없다. 왜냐하면 A는 남아있는 회의 중에서 가장 먼저 끝나는 회의이니 A가 B보다 먼저 끝난다. 그러면 회의 A말고 B를 선택했을 경우 더 많은 스케줄을 선택할 수 잇다고 했는데, B를 A로 바꾸는 것이 가능하고, A를 선택하는 방법이 B를 선택했을 때 적어도 B를 선택했을 때 만큼의 회의 수는 보장이 된다. 그래서 모순이다
    - 이 증명은 지금 최선의 선택을 하지 않았을 경우 최선의 선택을 했을 때 보다 더 결과가 좋아질 수 없음을 보인거고 내가 떠올린 그리디 알고리즘이 올바른지 확인할 때 지금 당장 손해를 보더라도 나중 가서는 이득인 경우가 있을 수는 없는지 고민해보면 정당성을 증명하거나 반례를 찾을 때 도움이 된다

  - 구현
    - 매 순간 남아있는 회의 중에서 가장 먼저 끝나는 회의를 찾으려고 하기 보다는 적절히 정렬을 하고 하나씩 보면서 이 회의를 현재 상황에서 스케줄에 넣을 수 있는지 본다
    - 정렬은 끝나는 시간이 빠른 순으로, 끝나는 시간이 같다면 시작 시간이 빠른 순으로 정렬하면 되는데, 시작 시간이 빠른 순으로 정렬을 하는 이유는 시작과 끝나는 시간이 같은 회의의 존재때문이다. (1, 2), (2, 2) 두 개가 있다고 할 때 시작시간을 빠른 순으로 정렬해주지 않는다면 (2, 2)가 선택될 수 있고 회의 두 개가 진행될 수 있음에도 불구하고 (2, 2)가 선택되면 한 개의 회의만 진행되기 때문이다

## 0x03 연습 문제 3- 로프

- 일단 이 문제가 그리디 알고리즘으로 해결될 수 있다고 생각하지 않을 때 떠올릴 수 있는 문제 풀이 방안
  - 모든 줄의 조합을 생각해볼 수 있다 → O($2^N$)
- 관점을 바꿔서 사용할 로프의 개수를 정해뒀다면 어떨까?
  - 만약 5개 로프 중 3개만 선택할 수 있는 상황이라고 하면 5개 중 가장 중량이 큰 3개를 선택한다
  - 이것이 정당할까? 가장 중량이 큰 3개가 아니라 다른 것을 끼워넣었고 최대가 되는지 증명하면 되는데, 모순이다. → 귀류법

## 0x04 연습 문제 4 - 보물

- 일단 이 문제가 그리디 알고리즘으로 해결될 수 있다고 생각하지 않을 때 떠올릴 수 있는 문제 풀이 방안
  - 모든 A 수열의 순열을 생각해볼 수 있다 → O($N!$)
- 그리디 풀이
  - A를 내림차순으로, B를 오름차순으로 정렬한 뒤 S를 만들면 최소가 된다
  - 정당성 증명 A를 정렬 안하고, B를 정렬 안해도 최소의 S가 나올 수 있다고 가정 → 재배열 부등식
  - 문제에서 B는 재배열하면 안된다 했으나 재배열해도 답에 지장이 없기 때문에 해도 무방하다

## 0x05 잘못된 그리디

- 그리디의 부작용은 그리디로 최적의 해가 나올 수 있는 것이 아닌 문제도 그리디로 보인다는 것
- 그 반례로 몇 가지 문제들을 살펴보려 한다
- 12865 - 평범한 배낭

  - 무게 제한 10일 때

    ![3](https://user-images.githubusercontent.com/48282185/176848546-f475d848-d802-427f-8dff-a5583f5fb718.png)

  - 그리디 풀이는 무게 대비 가치가 제일 큰 것을 선택하여 총 가치가 7이지만 최적의 해는 무게 10에 가치 9이다
  - 이 문제는 0 -1 knapsack으로 유명한 dp문제이다

- 1477 - 휴게소 세우기
  - 떠오르는 그리디 풀이는 현재 가장 긴 휴게소가 없는 구간의 중간에 계속 휴게소를 세워나가는 방법인데, 반례로는 휴게소가 아예 없을 때 2개의 휴게소를 더 짓는 문제에서 그리디는 500과 250을 답으로 주지만 최적의 해는 333, 666이다
  - 이 문제는 parametric search를 사용하여 풀 수 있다
- 문제가 그리디라는 것을 알고 푸는 것과 모르고 푸는 것에는 큰 차이가 있다 그래서 그리디 유형을 연습할 때는 일단 다른 풀이가 있을지 생각해본 뒤에 시간복잡도가 너무 클 경우, 점점 범위를 줄여나가면서 이것이 그리디구나를 깨닫는 것이 중요하다

> 바킹독님 유튜브 강의를 참고하여 제작하였습니다.
